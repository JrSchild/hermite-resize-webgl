<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>WebGL - 2D Image</title>

  <!-- vertex shader -->
  <script id="2d-vertex-shader" type="x-shader/x-vertex">
    attribute vec2 a_position;
    attribute vec2 a_texCoord;
    uniform vec2 u_resolution;
    varying vec2 v_texCoord;

    void main() {
      vec2 clipSpace = (a_position / u_resolution * 2.0) - 1.0;

      gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);

      v_texCoord = a_texCoord;
    }
  </script>

  <!-- fragment shader -->
  <script id="2d-fragment-shader" type="x-shader/x-fragment">
    precision highp float;

    uniform sampler2D u_image;
    uniform vec2 u_resolution; // W2 (width), H2 (height)
    uniform vec2 u_srcResolution; // W (width), H (height)
    varying vec2 v_texCoord;

    void main() {
      // I guess pizelStep is more precise if it's calculated within
      // the shader, rather than passed as uniform-value. Also these
      // should be defined in one place.
      vec2 srcPixelStep = vec2(1) / u_srcResolution;
      vec2 ratio = u_srcResolution / u_resolution;
      vec2 ratioHalf = ceil(ratio / vec2(2));

      // Location in pixels on target canvas.
      vec2 loc = v_texCoord * u_resolution; // j (height), i (width)

      float x2 = (loc.x + loc.y * u_resolution.x) * 4.0;
      float weight = 0.0;
      float weights = 0.0;
      float weights_alpha = 0.0;
      float gx_r = 0.0;
      float gx_g = 0.0;
      float gx_b = 0.0;
      float gx_a = 0.0;
      float center_y = (loc.y + 0.5) * ratio.y;

      // Due to restrictions in for-loop we have to use annoying work around.
      // http://www.atmind.nl/?p=623
      int yy = int(floor(loc.y * ratio.y));
      int yy_length = int((loc.y + 1.0) * ratio.y);
      for (int yyy = 0; yyy < 1000; yyy++) {
        if (yy >= yy_length) { break; }

        float dy = abs(center_y - (float(yy) + 0.5)) / ratioHalf.y;
        float center_x = (loc.x + 0.5) * ratio.x;
        float w0 = dy*dy;
      }

      // Move everything exactly 30px left and up:
      vec2 target = v_texCoord + (vec2(30) * srcPixelStep);

      gl_FragColor = texture2D(u_image, target);
    }
  </script>
</head>
<body>
  <script src="/bower/blueimp-canvas-to-blob/js/canvas-to-blob.js"></script>
  <script src="/src/webgl-utils.js"></script>
  <script src="/src/hermite-resize-webgl.js"></script>
  <script>
    function downloadLink(canvas) {
      canvas.toBlob(function (bb) {
        var a = document.createElement('a');
        a.download = 'hamster-cropped.png';
        a.href = window.URL.createObjectURL(bb);
        a.textContent = 'Click here for download';
        document.body.appendChild(a);
      });
    }
  </script>
  <script>
    var glScale = GLScale();

    glScale({
      image: '/hamster.jpg',
      width: 400,
      height: 300
    }, function (canvas) {
      document.body.appendChild(canvas);
      downloadLink(canvas);
    });
  </script>
</body>
</html>