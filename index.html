<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>WebGL - 2D Image</title>

  <!-- vertex shader -->
  <script id="2d-vertex-shader" type="x-shader/x-vertex">
    attribute vec2 a_position;
    attribute vec2 a_texCoord;
    uniform vec2 u_resolution;
    varying vec2 v_texCoord;

    void main() {
      vec2 clipSpace = (a_position / u_resolution * 2.0) - 1.0;

      gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);

      v_texCoord = a_texCoord;
    }
  </script>

  <!-- fragment shader -->
  <script id="2d-fragment-shader" type="x-shader/x-fragment">
    precision highp float;

    uniform sampler2D u_image;
    uniform vec2 u_resolution; // W2 (width), H2 (height)
    uniform vec2 u_srcResolution; // W (width), H (height)
    varying vec2 v_texCoord;

    // Convert a location on the texture in pixels, to the location in coordinates
    vec4 pixelsToTexture(vec2 loc) {
      vec2 target = loc / u_srcResolution;
      target.y = 1.0 - target.y;

      return texture2D(u_image, target);
    }

    void main() {
      // I guess ratio and ratioHalf are more precise when calculated within
      // the shader, rather than passed as uniform-value. Also these
      // should be defined in one place.
      vec2 ratio = u_srcResolution / u_resolution;
      vec2 ratioHalf = ceil(ratio / 2.0);

      // Location in pixels on target canvas.
      vec2 loc = gl_FragCoord.xy; // j (height), i (width)

      float x2 = (loc.x + loc.y * u_resolution.x) * 4.0;
      float weight = 0.0;
      float weights = 0.0;
      float weights_alpha = 0.0;
      vec3 gx_rgb = vec3(0.0);
      float gx_a = 0.0;
      float center_y = (loc.y + 0.5) * ratio.y;

      // Due to restrictions in for-loop we have to use awkward work-around.
      // http://www.atmind.nl/?p=623
      float yy = floor(loc.y * ratio.y);
      float yy_length = (loc.y + 1.0) * ratio.y;
      for (int yyy = 0; yyy < 5000; yyy++) {
        if (yy >= yy_length) { break; }

        float dy = abs(center_y - (yy + 0.5)) / ratioHalf.y;
        float center_x = (loc.x + 0.5) * ratio.x;
        float w0 = dy*dy;

        float xx = floor(loc.x * ratio.x);
        float xx_length = (loc.x + 1.0) * ratio.x;
        for (int xxx = 0; xxx < 5000; xxx++) {
          if (xx >= xx_length) { break; }

          // TODO: Rewrite image-buffer index to location-vector/percentage-based calculations.
          float dx = abs(center_x - (xx + 0.5)) / ratioHalf.x;
          float w = sqrt(w0 + dx*dx);

          if (w >= -1.0 && w <= 1.0) {
            // Hermite filter
            weight = 2.0 * w*w*w - 3.0*w*w + 1.0;
            if (weight > 0.0) {
              vec4 pixel = pixelsToTexture(vec2(xx, yy)) * 255.0;

              // Alpha
              gx_a += weight * pixel.a; // Convert alpha to 8 bit system.
              weights_alpha += weight;

              if (pixel.a < 255.0) {
                weight = weight * pixel.a / 250.0;
              }

              gx_rgb += weight * pixel.rgb;
              weights += weight;
            }
          }

          xx++;
        }

        yy++;
      }

      gx_rgb = (gx_rgb / weights) / 255.0;
      gx_a = (gx_a / weights_alpha) / 255.0;

      gl_FragColor = vec4(gx_rgb, gx_a);
    }
  </script>
</head>
<body>
  <script src="/src/webgl-utils.js"></script>
  <script src="/src/hermite-resize-webgl.js"></script>
  <script>
    function downloadLink(canvas) {
      canvas.toBlob(function (bb) {
        var a = document.createElement('a');
        a.download = 'hamster-cropped.png';
        a.href = window.URL.createObjectURL(bb);
        a.textContent = 'Click here to download';
        document.body.appendChild(a);
      });
    }
  </script>
  <script>
    var glScale = GLScale();

    glScale({
      image: '/hamster.jpg',
      width: 400,
      height: 300
    }, function (canvas) {
      document.body.appendChild(canvas);
      downloadLink(canvas);
    });
  </script>
</body>
</html>