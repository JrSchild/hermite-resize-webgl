<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>WebGL - 2D Image</title>

  <!-- vertex shader -->
  <script id="2d-vertex-shader" type="x-shader/x-vertex">
    attribute vec2 a_position;
    attribute vec2 a_texCoord;
    uniform vec2 u_resolution;
    varying vec2 v_texCoord;

    void main() {
      vec2 clipSpace = (a_position / u_resolution * 2.0) - 1.0;

      gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);

      v_texCoord = a_texCoord;
    }
  </script>

  <!-- fragment shader -->
  <script id="2d-fragment-shader" type="x-shader/x-fragment">
    precision highp float;

    uniform sampler2D u_image;
    uniform vec2 u_resolution; // W2 (width), H2 (height)
    uniform vec2 u_srcResolution; // W (width), H (height)
    varying vec2 v_texCoord;

    void main() {
      // I guess pizelStep is more precise if it's calculated within
      // the shader, rather than passed as uniform-value. Also these
      // should be defined in one place.
      vec2 srcPixelStep = vec2(1) / u_srcResolution;
      vec2 ratio = u_srcResolution / u_resolution;
      vec2 ratioHalf = ceil(ratio / vec2(2));

      // Location in pixels on target canvas.
      vec2 loc = floor(v_texCoord * u_resolution + vec2(0.5)); // j (height), i (width)

      float x2 = (loc.x + loc.y * u_resolution.x) * 4.0;
      float weight = 0.0;
      float weights = 0.0;
      float weights_alpha = 0.0;
      float gx_r = 0.0; // TODO: vec3 gx_rgba = vec3(0.0);
      float gx_g = 0.0;
      float gx_b = 0.0;
      float gx_a = 0.0;
      float center_y = (loc.y + 0.5) * ratio.y;

      // Due to restrictions in for-loop we have to use awkward work-around.
      // http://www.atmind.nl/?p=623
      float yy = floor(loc.y * ratio.y);
      float yy_length = (loc.y + 1.0) * ratio.y;
      for (int yyy = 0; yyy < 5000; yyy++) {
        if (yy >= yy_length) { break; }

        float dy = abs(center_y - (float(yy) + 0.5)) / ratioHalf.y;
        float center_x = (loc.x + 0.5) * ratio.x;
        float w0 = dy*dy;

        float xx = floor(loc.x * ratio.x);
        float xx_length = (loc.x + 1.0) * ratio.x;
        for (int xxx = 0; xxx < 5000; xxx++) {
          if (xx >= xx_length) { break; }

          // TODO: Rewrite image-buffer index to location-vector/percentage-based calculations.
          float dx = abs(center_x - (float(xx) + 0.5)) / ratioHalf.x;
          float w = sqrt(w0 + dx*dx);

          if (w >= -1.0 && w <= 1.0) {
            // Hermite filter
            weight = 2.0 * w*w*w - 3.0*w*w + 1.0;
            if (weight > 0.0) {
              vec2 xxyy = vec2(xx, yy) * u_resolution;
              vec4 pixel = texture2D(u_image, xxyy) * vec4(255.0);

              // Alpha
              gx_a += weight * pixel.a; // Convert alpha to 8 bit system.
              weights_alpha += weight;

              if (pixel.a < 255.0) {
                weight = weight * pixel.a / 250.0;
              }
              // TODO: Use to vector.
              gx_r += weight * pixel.r;
              gx_g += weight * pixel.g;
              gx_b += weight * pixel.b;
              weights += weight;
            }
          }

          xx++;
        }
        
        yy++;
      }

      // Move everything exactly 30px left and up:
      vec2 target = v_texCoord + (vec2(30) * srcPixelStep);

      gl_FragColor = texture2D(u_image, target);

      // gl_FragColor = vec4(loc.x / 255.0, loc.y / 255.0, 0.6, 1.0);
      // gl_FragColor = vec4((gx_r / weights) / 255.0,(gx_g / weights) / 255.0,(gx_b / weights) / 255.0,gx_a / 255.0);
    }
  </script>
</head>
<body>
  <script src="/bower/blueimp-canvas-to-blob/js/canvas-to-blob.js"></script>
  <script src="/src/webgl-utils.js"></script>
  <script src="/src/hermite-resize-webgl.js"></script>
  <script>
    function downloadLink(canvas) {
      canvas.toBlob(function (bb) {
        var a = document.createElement('a');
        a.download = 'hamster-cropped.png';
        a.href = window.URL.createObjectURL(bb);
        a.textContent = 'Click here for download';
        document.body.appendChild(a);
      });
    }
  </script>
  <script>
    var glScale = GLScale();

    glScale({
      image: '/hamster.jpg',
      width: 400,
      height: 300
    }, function (canvas) {
      document.body.appendChild(canvas);
      downloadLink(canvas);
    });
  </script>
</body>
</html>